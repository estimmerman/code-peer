The purpose of CodePeer is to be an online office-hours of sorts. Its function is to connect CS students and teaching fellows or peer tutors for help and collaboration on assignments. A student can simply create an account and begin a coding session, which a tutor can then join for realtime code sharing and chatting.

CodePeer is a web application created using Node.js and MongoDB. I use Express.js as a framework on top of Node.js, Jade as an HTML templating engine since it's easy to use with Node.js, and Socket.io for the websockets used to communicate between client browsers during sessions. I didn't specifically choose to use Node.js and MongoDB for any reason besides that I hadn't used them before and wanted to learn how to. In the end, MongoDB coupled with the mongoose module made declaring model schemas and querying very easy.

The only database models required for the application are Users and CodeSessions. Each user has a unique session associated with them, which is updated and activated/deactivated. Thus, a user never really creates more than one session model, even though it may seem like they are when clicking 'Begin Session'. There is a strictly 1:1 association between Users and CodeSessions. The purpose of this is to allow for convenience of accessing previously written sessions (so if the user ends a session and begins their next one, they will see the code from the previous one, in case they accidently ended it previously) and to reduce data writing to the databases. Were a user to start thousands of sessions, over time there would be a very large number of sessions in the database, which for the purpose of this application didn't seem quite necessary. Ultimately if the project were to be expanded to have the folder/directory functionality of Cloud9, this single session per user would still be viable, and would make easier the division of coding projects.

Here's a basic overview of the flow of the application. A user is created as either a student or a tutor (their role in the User model is either 0 or 1). If they are a student, they will have the ability to begin a coding session. When they start their first session, a CodeSession model will be created with a unique shortcode. This will be the sole session that is associated with this user. Whenever they begin a session, it will be set as active, and tutors can see the session in their list. When the end a session, it will be set as inactive, no longer being visible to tutors. All code or language updates done will be saved to this session. On ending of a session, the code/language is NOT reset, so when the session is made active the next time, you will see the same settings and state as before. If the new user is a tutor, their home screen will consist of a list of all active student sessions. They have the ability to filter this list via a dropdown in the header. A tutor can join any non-full session (a session can have at max 1 student and 1 tutor in it at a time). A session is determined to be full by the number of active users in it. Whenever someone joins a session, be it a student or a tutor, a POST is sent to the server upon connection of the socket.io server in that client, which then updates the activeUsers field in the session, adding that user's id to it. A user can only leave a session (they are no longer part of activeUsers) by either clicking 'End Session' or 'Leave Session', if they are a student or tutor respectively. I don't remove users based on the socket.io server disconnecting, so that students and/or tutors can temporarily leave a session without allowing another tutor to enter it, since it remains full. Also, since I kick the tutor out if a student ends a session, I didn't want a tutor to be kicked out in case the student lost connection or refreshed their page, all of which would disconnect the socket.io server. As a side not, a tutor can only be in 1 active session at a time.

Socket.io is the main websockets plugin I use for communication between active browsers in a session. Whenever a person visit a session page (/session/:shortCode), I connect a socket to the Socket.io server I initialize upon the application start (in app.js). This socket will be used by the client to emit and respond to several events. They will emit events whenever a user joins, a chat message is sent, code is updated on their end, or the coding language is changed. They will respond to events on users connecting and disconnecting (seen in the chat), chat messages sent from other clients, and code and language updates from other clients. The Socket.io server is the middleman so-to-say, which listens for events emitted by the client sockets, and broadcasts these events to all other sockets in that session. I am able to control which sockets to broadcast these events to, because I create 'rooms' in the socket.io server based on the shortcode of that session. Each client socket joins the room corresponding to their session, and only receives events emitted by other client sockets in this room.

CodeMirror is the plugin I use for the code editor in the sessions. It is a useful plugin which handles the syntax highlighting for the code. Whenever a new language is chosen, I merely update the 'mode' associated with the editor to the new language (of which there are many to choose from). Within a coding session, I perform automatic saving of changes to the editor on a 5 second interval, unless a user manually saves their code. A save will only occur if actual changes have been made. Also in a session, a user can change the theme of both their editor and the chat area via a dropdown in the header. When a theme for the editor is changed, I update the 'theme' field of the editor object upon initialization of it. The chat themes are custom-made by myself, while the editor themes were examples given within the plugin that I decided to adopt.

Some other small technical design details: I use a module passport for user authentication during login and signup, and nodemailer coupled with SendGrid to send emails. Of course, I also use Bootstrap and jQuery as a CSS/JS library since they're so convenient.